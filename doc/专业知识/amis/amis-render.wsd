@startuml amis渲染流程
boundary System
' participant "Renderer(config)" as Renderer
' participant "closureA(config)" as closureA
' participant "registerRenderer(component)" as registerRender
' System --> Renderer ++ : 调用amis入口函数生成amis组件树
' Renderer --> registerRender ++ : 调用闭包注册渲染器，并返回渲染器
participant "render(schema, props, options, pathPrefix)" as render
participant AMISRender
participant "StatusScoped(ComposedComponent)" as StatusScoped
participant "HocScoped(ComposedComponent, rendererType)" as Scoped
participant Root
participant RootRender #00a3fe
participant renderChild
participant renderChildren
participant ScopedComponent #00a3fe
participant ScopedRootRenderer #00a3fe

System -[#00a3fe]-> render ++ : 调用渲染函数，生成amis组件树【本质是React】
render -[#00a3fe]-> AMISRender ++ :组合，props
AMISRender --> StatusScoped ++: 调用
    StatusScoped --> Scoped ++ : 调用
        return ScopedComponent
    return ScopedRootRenderer
AMISRender -[#00a3fe]-> ScopedRootRenderer ++: 组合，props
note right
AMISRender
 1、计算locale
 2、计算translate
 3、生成rootStore:RendererStore
 4、计算theme
 5、替换schema中的字符
 6、计算env
 7、成为EnvContext的生产者本质就是env
 props传递1、2、3、4、6
end note
ScopedRootRenderer -[#00a3fe]-> ScopedComponent ++: 组合，props
note right
ScopedRootRenderer
1、计算并维护statusStore
2、计算ref或forwardRef
props传递1、2
end note
ScopedComponent -[#00a3fe]-> Root ++ : 组合，props
note right
ScopedComponent
1、计算scoped，并成为ScopedContext的生产者
ScopedContext提供scoped
同时拦截scopeRef的传递
end note
Root -[#00a3fe]-> RootRender ++ : 组合，props
note right
1、计算render
2、计算resolveDefinitions
3、计算children即RootRender
props传递
end note
RootRender -[#00a3fe]-> RootRender ++: 调用render，传递props
note right
1、计算this.store:IRootStore
2、计算topStore=this.store
3、计算data=this.store.downStream
4、context=store.context
props透传给render
end note
return ComponentTree

return ComponentTree
return ComponentTree
return ComponentTree
return ComponentTree
return ComponentTree
return ComponentTree
@enduml