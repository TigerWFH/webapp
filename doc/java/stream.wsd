@startuml stream
    interface AutoClosable {
        + {abstract} void close()
    }
    interface BaseStream<T, S extends BaseStream<T, S>> {
        + {abstract} Iterator<T> iterator()
        + {abstract} Spliterator<T> spliterator()
        + {abstract} boolean isParallel()
        + {abstract} S parallel()
        + {abstract} S unordered()
        + {abstract} S onClose(Runnable closeHandler)
        + {abstract} void close()
    }
    interface Stream<T> {
        + {abstract} Stream<T> filter(Predicate<? super T> predicate)
        + {abstract} <R> Stream<R> map(Function<? super T, ? extends R> mapper)
        + {abstract} Instream mapToInt(ToIntFunction<? super T> mapper)
        + {abstract} LongStream mapToLong(ToLongFunction<? super T> mapper)
        + {abstract} DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper)
        + {abstract} <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)
        + {abstract} IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper)
        + {abstract} LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper)
        + {abstract} DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper)
        + {abstract} Stream<T> distinct()
        + {abstract} Stream<T> sorted()
        + {abstract} Stream<T> sorted(Comparator<? super T> comparator)
        + {abstract} Stream<T> peek(Consumer<? super T> action)
        + {abstract} Stream<T> limit(long maxSize)
        + {abstract} Stream<T> skip(long n)
        + {abstract} void forEach(Consumer<? super T> action)
        + {abstract} void forEachOrdered(Consumer<? super T> action)
        + {abstract} Object[] toArray()
        + {abstract} <A> A[] toArray(IntFunction<A[]> generator)
        + {abstract} T reduce(T identity, BinaryOperator<T> accumulator)
        + {abstract} Optional<T> reduce(BinaryOperator<T> accumulator)
        + {abstract} <U> U reduce(U identity,BiFunction<U, ? super T, U> accumulator,BinaryOperator<U> combiner)
        + {abstract} <R> R collect(Supplier<R> supplier,BiConsumer<R, ? super T> accumulator,BiConsumer<R, R> combiner)
        + {abstract} <R, A> R collect(Collector<? super T, A, R> collector)
        + {abstract} Optional<T> min(Comparator<? super T> comparator)
        + {abstract} Optional<T> max(Comparator<? super T> comparator)
        + {abstract} long count()
        + {abstract} boolean anyMatch(Predicate<? super T> predicate)
        + {abstract} boolean allMatch(Predicate<? super T> predicate)
        + {abstract} boolean noneMatch(Predicate<? super T> predicate)
        + {abstract} Optional<T> findFirst()
        + {abstract} Optional<T> findAny()
        + {static} <T> Builder<T> builder()
        + {static} <T> Stream<T> empty()
        + {static} <T> Stream<T> of(T t)
        + {static} <T> Stream<T> of(T... values)
        + {static} <T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)
        + {static} <T> Stream<T> generate(Supplier<T> s)
        + {static} <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
    }
    BaseStream <|-- Stream

    class Collectors {
        - Collectors()
        + {static} <T, C extends Collection<T>> Collector<T, ?, C> toCollection(Supplier<C> collectionFactory)
        + {static} <T> Collector<T, ?, List<T>> toList()
        + {static} <T> Collector<T, ?, Set<T>> toSet()
        + {static} Collector<CharSequence, ?, String> joining()
        + {static} Collector<CharSequence, ?, String> joining(CharSequence delimiter)
        + {static} Collector<CharSequence, ?, String> joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)
        + {static} <T, U, A, R> Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper, Collector<? super U, A, R> downstream)
        + {static} <T, A, R, RR> Collector<T, A, RR> collectingAndThen(Collector<T, A, R> downstream, Function<R, RR> finisher)
        + {static} <T> Collector<T, ?, Long> counting()
        + {static} <T> Collector<T, ?, Optional<T>> minBy(Comparator<? super T> comparator)
        + {static} <T> Collector<T, ?, Integer> summingInt(ToIntFunction<? super T> mapper)
        + {static} <T> Collector<T, ?, Long> summingLong(ToLongFunction<? super T> mapper)
        + {static} <T> Collector<T, ?, Double> summingDouble(ToDoubleFunction<? super T> mapper)
    }
@enduml